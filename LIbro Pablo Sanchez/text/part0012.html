<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>CONST_PRUEBA_EBOOK_FINAL-12</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body id="CONST_PRUEBA_EBOOK_FINAL" xml:lang="en-US" class="calibre">
		<div class="marco-de-texto-b-sico">
			<p id="toc_marker-12" class="heading">Esto está listo</p>
			<p class="normal4"><span>V</span>amos<span> </span>a<span> </span>desc<span>r</span>ibir<span> </span>dos<span> </span>situaciones<span> </span>qu<span>e</span>,<span> </span>aunque<span> </span>no<span> </span>son<span> </span><span>to</span>talmente<span> </span><span>r</span><span>eales,</span><span> </span>fue<span>r</span>on<span> </span><span>inspiradas</span><span> </span>por<span> </span>episodios<span> </span>de<span> </span><span>p</span><span>r</span><span>o</span><span>y</span><span>ec</span>tos<span> </span>pasados. </p>
			<p class="normal4"><span class="char-style-override2">Situación 1</span></p>
			<p class="normal4">Los desarrolladores y testers de un equipo se encuentran en una reunión. Están investigando la causa de unos defectos que se filtraron en una entrega al cliente. Los testers dicen que llegan demasiados defectos que consideran de sentido común y que eso les quitó tiempo para hacer las pruebas de regresión. Los desarrolladores argumentan que los testers reportan incidentes sobre casos que no estaban especificados. Cuando entran en detalle, se dan cuenta que todas las pantallas desarrolladas tienen problemas menores visuales y en muchas faltan validaciones o mensajes.</p>
			<p class="normal4"><span class="char-style-override2">Situación 2</span></p>
			<p class="normal4">Llega el día de la demostración del producto  y un integrante del equipo expone ante el cliente la funcionalidad comprometida. Se había pedido un módulo que imprimiera tickets para eventos deportivos. La reunión es todo un éxito y el sistema funciona correctamente. Sin embargo, al cabo de unos días de instalado en producción, empiezan a llegar pedidos para arreglar el producto porque no está funcionando bien. Al consultar sobre la falla, el cliente informa que el sistema está dando problemas con las impresiones. En la charla menciona que el área de tecnología cambió todas las impresoras el mes anterior para reemplazar las viejas, que tenían 5 años de antigüedad. A la vez, muchos errores reportados corresponden a problemas con la impresión de textos dado que la empresa decidió utilizar el software en su filial árabe donde los textos deben escribirse de derecha a izquierda. El responsable del proyecto explica que las pruebas se habían realizado con otra impresora y en castellano. El cliente responde que, dado que la unidad de negocios más grande está en Medio Oriente, no se puede considerar terminado un producto que no satisface su filial más importante. El equipo se resigna y se queja porque en los proyectos siempre pasan estas cosas.</p>
			<p class="normal4">Estas situaciones son muy comunes en los proyectos de desarrollo. Una parte cree que cumplió con el trabajo pero cuando la otra lo recibe no satisface las expectativas. Muchas veces, se asumen reglas implícitas que después resultan inexistentes. También es común que una parte considere que su trabajo está suficientemente bien como para ser entregado. La comunicación es uno de los elementos esenciales a gestionar durante un proyecto y muchos problemas pueden generarse por malos entendidos, suposiciones, por no aclarar algún punto, o por ser ambiguo.</p>
			<p class="normal4">Si analizamos la primera situación, lo que el equipo de desarrollo consideraba terminado, era algo inestable para testing. Por este motivo, los testers lo devolvían con gran cantidad de bugs reportados, generando varias idas y vueltas. Es decir, no había un acuerdo sobre la calidad mínima que la entrega debía tener para considerarse completa. Estas idas y vueltas dejaban menos tiempo para probar todo el sistema y, por consiguiente, el resultado final era una entrega inestable.</p>
			<p class="normal4">En la segunda situación tenemos varios problemas. En primer lugar, ni el equipo ni el cliente tienen claro el alcance de la entrega. Los primeros consideran que el sistema entregado está funcionando bien porque permite imprimir recibos en castellano pero el cliente esperaba que funcione también en árabe y esto último no fue contemplado.</p>
			<p class="normal4">Podríamos suponer que existió un problema en el relevamiento por parte del equipo, ya que no fue capaz de reconocer una necesidad que aportaba valor para esta empresa (la impresión de tickets en árabe). Pero, por otro lado, también hubo problemas para delimitar el alcance de la funcionalidad, puesto que como el cliente se quejó y el equipo no supo cómo responder más allá de la queja, queda en evidencia que nunca hubo un entendimiento común de lo que se esperaba de la funcionalidad.</p>
			<p class="normal4">Cuando  hablamos de falta de entendimiento  común, no es solo que ambos sepan que se va a hacer, sino que es fundamental que las dos partes estén de acuerdo <span class="char-style-override">sobre cuando la pieza  construida estará completa</span><span class="char-style-override6"><a id="footnote-668-82-backlink" href="part0012.html#footnote-668-82">82</a></span><span class="char-style-override">.</span> Esto se puede ver bien en el ejemplo, porque aunque el equipo le dé la razón al cliente y arregle el software para que funcione en árabe, este luego puede volver a quejarse en unos meses porque la versión japonesa o china no imprime bien y una vez arreglados estos problemas, seguiríamos con otros sistemas de escritura cada vez más raros para nosotros. El problema no está en el software sino en que las partes nunca entendieron lo mismo sobre lo que había que hacer.</p>
			<p class="normal4">Entonces, más allá del problema de relevamiento, vemos que no dejar claro el alcance de una funcionalidad genera falsas expectativas, frustraciones, trabajo adicional y roces en la relación equipo-cliente. En este caso, el equipo tendría que haber utilizado alguna técnica para acordar de antemano qué puntos tienen que cumplirse para que se considere aprobada una funcionalidad y una entrega.</p>
			<p class="normal4">Para complicar más el tema, tenemos el problema de funcionamiento con las nuevas impresoras. El equipo empezó el desarrollo para un dispositivo que más adelante fue cambiado por un área no directamente vinculada con el proyecto. Lo que sucede en este caso lo podemos considerar como una modificación en el ambiente original y, aunque es muy poco probable que estas situaciones puedan evitarse, existen formas de mitigar riesgos <span class="char-style-override">acordando las condiciones sobre las cuales se realizarán las pruebas o la aceptación del producto.</span></p>
			<p class="normal4">Ambas situaciones surgen por diferencias entre lo que ambas partes entienden por una entrega de calidad aceptable. Ambas generan trabajo adicional, desvían el foco del proyecto y generan roces entre los participantes, pero la segunda situación tiene el inconveniente de ser una entrega al cliente y generalmente condicionar pagos, bonos, cerrar etapas, liberar parte del equipo para nuevos proyectos, iniciar nuevas oportunidades, etc. Por esto, definir qué significa que algo está listo debería ser considerado crítico para el éxito de un proyecto.</p>
			<p class="normal4"><span class="char-style-override2">A mí me funciona</span></p>
			<p class="normal4">Podemos identificar varios problemas típicos que aparecen en el trabajo diario de un equipo y entre el equipo y su cliente. A continuación, algunos ejemplos:</p>
			<p class="normal4"><span class="char-style-override">El código no compila: </span>este es un caso lamentablemente recurrente que, por suerte y gracias a las técnicas de integración continua, está desapareciendo. Es el típico caso en que un integrante no envía la totalidad de sus cambios al repositorio y no verifica si la nueva versión compila.</p>
			<p class="normal4"><span class="char-style-override">La entrega tiene funcionalidad incompleta: </span>si bien a primera vista parece que todo anda bien, el sistema carece de algunas características menores solicitadas como el envío de notificaciones por mail o guardar datos en un registro de auditoría o comunicar cambios a algún sistema externo. En líneas generales, puede ser que una funcionalidad esté desarrollada pero no haga todo lo que tiene que hacer.</p>
			<p class="normal4"><span class="char-style-override">La entrega no tiene tests unitarios: </span>el desarrollador no entrega las pruebas que validan que su código hace lo que tiene que hacer. Para tener conciencia de lo importante que son los tests unitarios, en algunos equipos, no entregar pruebas unitarias es equivalente a no entregar. Si alguien no puede asegurar que lo que desarrolló funciona es muy probable que otro tenga que verificarlo por él más tarde. Esto generará idas y vueltas innecesarias si es que faltaba contemplar algún punto. Por lo tanto, en estos equipos, funcionalidad entregada sin pruebas unitarias no se acepta.</p>
			<p class="normal4"><span class="char-style-override">Validaciones no realizadas: </span>todo funciona siempre y cuando nos acordemos de completar todos los campos del formulario, de no poner letras cuando nos piden números, de acordarnos de ingresar las fechas en formato dd-mm-aaaa. Si nos olvidamos de cumplir con alguna de estas reglas, el sistema falla o peor, queda en un estado interno inconsistente.</p>
			<p class="normal4"><span class="char-style-override">Solo se probó el camino feliz:  </span>es bastante común encontrar desarrollos en los que sólo se considera esta vía. Por ejemplo, si hay que enviar un mensaje por red podría ser que no se hubiese considerado que no haya conexión o que el receptor me responda con un mensaje no esperado.</p>
			<p class="normal4"><span class="char-style-override">Solo funciona en la máquina de quien lo desarrolló: </span>otro punto que es bastante frecuente encontrar, tiene que ver con funcionalidades que responden correctamente en el ambiente de desarrollo pero que por alguna diferencia de ambiente (configuración regional, software de base con otra versión, etc.) no funciona en el ambiente final. Esto también está disminuyendo con los servidores de integración continua pero aún ocurre.</p>
			<p class="normal4"><span class="char-style-override">No estaban definidas las pruebas: </span>un caso frecuente es desarrollar una funcionalidad sin conocer bien los criterios con los que va a ser verificada. Esta situación genera que muchos errores evitables lleguen a instancias muy avanzadas (aceptación de la entrega) para volver a desarrollo porque no cumplen con las expectativas de quien recibe el producto.</p>
			<p class="normal4"><span class="char-style-override">No se cumple con las pruebas: </span>puede darse el caso que estén definidas las pruebas pero que el desarrollador construya solo mirando la funcionalidad, sin validar que cumpla con las pruebas generadas. Como estas complementan la funcionalidad aportando casos especiales, muchas veces aparecen reglas de negocio que no fueron consideradas a pesar de que el desarrollador esté convencido de que terminó con su tarea.</p>
			<p class="normal4"><span class="char-style-override">Se entrega  con errores: </span>ningún software está libre de errores, pero cuando se realiza una entrega y esta contiene errores de una cierta criticidad, es esperable que vuelva rechazada. Si existen incidentes reportados para una funcionalidad y la cantidad o severidad de los mismos es considerable, es poco  probable que  podamos afirmar que el trabajo está terminado.</p>
			<p class="normal4"><span class="char-style-override">No cumple con los estándares acordados: </span>el equipo definió que había que respetar la notación estándar de código, que se iban a seguir ciertos patrones de arquitectura y diseño, que todos los mensajes se guardarán en la base de datos pero, sin embargo, nada o poco se cumple en el código que se acaba de enviar al repositorio. A veces son impuestos por el cliente por normativa de la empresa o para asegurarse un código legible cuando quede en su poder. Un incumplimiento de un estándar obliga a reprogramar y a pasar por las instancias de testing y aceptación nuevamente de manera innecesaria.</p>
			<p class="normal4"><span class="char-style-override">No cumple con  los  criterios estéticos  definidos: </span>la entrega está impecable a nivel funcional, pero el color elegido para los mensajes no tiene nada que ver con los que se definieron para la aplicación. También pasa con diferentes tonalidades, tamaños, tipografías, ubicación de controles, manejo de espacios, orden de tabulación, etc. Puede ser que no invaliden totalmente una entrega, pero no deberíamos considerar completa una funcionalidad que no respeta los criterios estéticos.</p>
			<p class="normal4"><span class="char-style-override">Solo funciona en algunas plataformas: </span>también es frecuente, por ejemplo en el desarrollo web, aunque no se limita a este tipo de proyectos. Se suele dar cuando un desarrollador programa con éxito una parte del sistema y la prueba en su navegador preferido. Luego, los usuarios utilizan otros navegadores y el sistema no funciona por incompatibilidad entre los mismos.</p>
			<p class="normal4">Como vemos, existen muchas categorías de problemas que surgen de la falsa sensación que tenemos al creer que terminamos de desarrollar la funcionalidad. Cada fuente de problemas es un aporte al mal funcionamiento del proyecto y un granito de arena para contribuir al derrumbe de las expectativas del cliente.</p>
			<p class="normal4"><span class="char-style-override2">Terminé es que terminé</span></p>
			<p class="normal4">Si queremos evitar los problemas que ya mencionamos, tenemos que poder dejar en claro que entendemos cuando decimos “está listo” o “terminé”.</p>
			<p class="normal4">Para que todos tengan un mismo entendimiento, lo mejor que se puede hacer es generar un listado de puntos que el equipo considera necesario verificar antes de poder decir que la tarea está completa. Para este caso son muy útiles las listas de verificación. Con esta herramienta se pueden definir cuáles son los ítems que deben estar cumplidos para que alguien pueda decir que su parte está completa.</p>
			<p class="normal4">Por ejemplo, podríamos definir una lista de verificación que defina que una funcionalidad de un desarrollador está completa siempre y cuando cumpla con cada uno de los puntos del siguiente listado:</p>
			<p class="normal4">• En el ambiente de desarrollo:</p>
			<p class="normal4">˚El código compila.</p>
			<p class="normal4">˚El código tiene sus pruebas unitarias.</p>
			<p class="normal4">˚Las pruebas se ejecutan correctamente.</p>
			<p class="normal4">˚Si hay pantallas, las mismas tienen todas sus entradas con validaciones.</p>
			<p class="normal4">˚Las pruebas fueron definidas.</p>
			<p class="normal4">˚Todas las pruebas se ejecutan exitosamente.</p>
			<p class="normal4">• Al integrarlo con el resto del código:</p>
			<p class="normal4">˚El código del sistema compila.</p>
			<p class="normal4">˚El ambiente de integración ejecuta todas las pruebas exitosamente.</p>
			<p class="normal4">Hay autores<span class="char-style-override3"><a id="footnote-668-83-backlink" href="part0012.html#footnote-668-83">83</a></span> que proponen diferentes listas de verificación que tratan de considerar todos los puntos a tener en cuenta cuando se desarrolla. En nuestra opinión, esto genera condiciones demasiado estrictas y el listado se vuelve tan grande que pierde su utilidad. Además, genera el rechazo de quienes lo usan porque lo ven como un impedimento para avanzar con su tarea. Muchas veces, estas listas de verificación entran en demasiado detalle solo para asegurar que ningún aspecto queda fuera de control y olvida que el objetivo fundamental de estas herramientas es cumplir con las expectativas de los clientes, eliminar el trabajo innecesario y entregar más valor en poco tiempo.</p>
			<p class="normal4">Por eso es importante que cada equipo, a medida que avanza el proyecto, vaya definiendo e incorporando  los puntos que considere necesarios<span class="char-style-override3"><a id="footnote-668-84-backlink" href="part0012.html#footnote-668-84">84</a></span>. Siempre resulta un compromiso más difícil de rechazar si los mismos integrantes del equipo asumen ese compromiso, y el mismo no viene impuesto de afuera.</p>
			<p class="normal4"><span class="char-style-override2">Quiero que me aprueben las entregas</span></p>
			<p class="normal4">Cuando tenemos que acordar los puntos que tienen que cumplirse para dar por aprobada una entrega recurrimos a los criterios de aceptación. Lo que se busca con estos es fijar las condiciones por escrito mediante las cuales la entrega se considerará aprobada.</p>
			<p class="normal4">Un ejemplo de criterio de aceptación podría ser:</p>
			<p class="normal4">Todas las pruebas de aceptación pasan exitosamente. </p>
			<p class="normal4">Existen 0 errores críticos, 0 medios y 4 menores.</p>
			<p class="normal4">A su vez, hay que definir sin ambigüedades a qué se considera error crítico, medio y menor.</p>
			<p class="normal3">Los criterios de aceptación no son solo un concepto ágil, sino que son utilizados ampliamente en la gestión de alcance de todo tipo de proyectos.</p>
			<p class="normal4">Ya hablamos de los criterios y casos de aceptación en el capítulo “Empezando por la aceptación”<span class="char-style-override">. </span>Allí explicamos que los métodos ágiles nos permiten ir construyendo estos casos a partir de la definición de diferentes ejemplos de uso del sistema. Es así que si una entrega consta de un conjunto de funcionalidades, mis casos de aceptación constarán de diferentes ejemplos de uso para cada una de estas funcionalidades.</p>
			<p class="normal4">Los casos de aceptación los vamos acordando con nuestro cliente en la medida que vamos relevando el sistema. Es decir, contribuyen, por un lado, a entender mejor la funcionalidad y, por otro, nos ayuda a generar el material que se utilizará para verificar si la entrega debe ser o no aprobada. El punto importante a tener en cuenta es que los casos deben estar escritos, o por lo menos propuestos, <span class="char-style-override">por el cliente </span>puesto que será él quien los utilice para validar las entregas.</p>
			<p class="normal4">Entrando en detalle, un caso de aceptación indica, para un posible uso de la funcionalidad que estamos desarrollando, el comportamiento que se espera del sistema. Pero es importante tener en cuenta que un caso de aceptación puede terminar expandiendo  esta funcionalidad y requiriendo nuevos comportamientos en el resto.</p>
			<p class="normal4">Vamos a poner  un ejemplo. Supongamos que estamos desarrollando un sistema para una empresa de tarjetas de crédito y tenemos la funcionalidad <span class="char-style-override">Abonar con tarjeta de crédito.</span></p>
			<p class="normal4">Los casos de aceptación que podrían surgir del intercambio con el cliente podrían incluir los siguientes:</p>
			<p class="normal4">Que cuando el usuario de tarjeta:</p>
			<p class="normal4">• Quiere pagar y tiene crédito, pueda realizar la compra.</p>
			<p class="normal4">• Quiere  pagar y no tiene crédito no pueda realizar la compra.</p>
			<p class="normal4">• Pague con la tarjeta, disminuya el crédito en la misma cantidad que la compra realizada.</p>
			<p class="normal4">• Intente pagar con la tarjeta y como está denunciada, no pueda realizar la compra.</p>
			<p class="normal4">• Ingrese datos inválidos, el sistema informe que los datos son incorrectos.</p>
			<p class="normal4">También podrían ser más específicos, por ejemplo:</p>
			<p class="normal4">Dado que el cliente tiene una tarjeta con crédito, número <span class="char-style-override">111111111111</span>,  vencimiento <span class="char-style-override">12/15  </span>y estado <span class="char-style-override">no denunciada</span>.</p>
			<p class="normal4">Cuando,</p>
			<p class="normal4">• Ingresa todos los datos de la tarjeta pero en el vencimiento  ingresa 12/15,  entonces el sistema muestra el mensaje “los datos de la tarjeta no son correctos”.</p>
			<p class="normal4">• Ingresa una fecha de vencimiento previa a la fecha actual, entonces el sistema muestra el mensaje “probablemente la tarjeta no esté vigente”.</p>
			<p class="normal4">• No  ingresa número  de  tarjeta, entonces  el  sistema muestra el mensaje “algunos datos no fueron completados”. Remarcando el campo del número de tarjeta.</p>
			<p class="normal4">Ahora bien, estos casos están directamente relacionados con la funcionalidad, pero podría haber otros que tengamos que tener en cuenta si es que ya existe otra funcionalidad a la que este nuevo desarrollo afecta. Siguiendo con nuestro ejemplo, supongamos que ya estaba desarrollado el resumen de cuenta del cliente y el informe diario de operaciones del comercio. En ese caso, es probable que el cliente aporte los siguientes casos de aceptación:</p>
			<p class="normal4">Dado que el usuario con una tarjeta con $15 de saldo realizó una compra por una botella de agua que costaba $5, cuando pague con la tarjeta,</p>
			<p class="normal4">• A fin de mes aparezca dicha compra en el resumen de cuenta y el saldo luego de esa compra sea de $10.</p>
			<p class="normal4">• En el informe diario de operaciones del comercio donde se concretó la compra, se visualice la compra realizada por $5.</p>
			<p class="normal4">¿Y si el usuario quiere garantizar algún tema relacionado con el rendimiento? En ese caso podría agregar casos de aceptación como los siguientes:</p>
			<p class="normal4">• Que cuando el sistema reciba 50 transacciones en un segundo procese las 50 transacciones.</p>
			<p class="normal4">• Que cuando el usuario pague con la tarjeta, el resultado de la operación se informe en menos de 5 segundos.</p>
			<p class="normal4">Si tenemos una entrega definida, su aceptación va a estar condicionada por el cumplimiento de todos los casos de aceptación que el cliente haya definido para las funcionalidades desarrolladas, las previas afectadas por esta entrega y las diferentes restricciones impuestas sobre las mismas. Todas estas cuestiones, como vimos, se pueden especificar mediante la técnica explicada arriba.</p>
			<p class="normal4">El otro punto a tener en cuenta, si recordamos la segunda situación al inicio del capítulo con el problema de la impresora, es sobre la definición del ambiente de aceptación. Es fundamental relevar las expectativas del cliente en cuanto al ambiente en el que espera ejecutar nuestro entregable.</p>
			<p class="normal4">En el caso del pago con tarjeta, se podrían incorporar ciertos casos de aceptación como los siguientes:</p>
			<p class="normal4">• Que cuando el pago se realice con las terminales T21, y Tz3 con las versiones de firmware 1.22, 1.23 y 2.0, el pago se registre correctamente.</p>
			<p class="normal4">Con este texto mínimo estamos limitando las posibilidades de rechazo de nuestra aplicación por ejecutarse en un ambiente no conocido. Al especificar los ambientes, el equipo de desarrollo sabe donde probar su trabajo, o al menos sabe que es lo que debe emular. Por otro lado, el cliente se asegura que el sistema que se está construyendo se ejecutará sin inconvenientes en estos dispositivos.</p>
			<p class="normal4">Lo que hay que evitar en estos casos son afirmaciones ambiguas del tipo: <span class="char-style-override">deberá funcionar con la última  versión del sistema operativo.</span></p>
			<p class="normal4">La idea, en definitiva, es que este listado de casos forma parte de la entrega y el cliente pueda ir revisando caso por caso y marcando si se cumplen o no como si estuviera verificando una lista de verificación. De esta manera, se logra generar un entendimiento común de la completitud de la entrega y se establece una técnica relativamente sencilla de verificar que se cumple con todo lo que el cliente espera.</p>
			<p class="normal4"><span class="char-style-override2">En resumen</span></p>
			<p class="normal4">Viendo la primera situación planteada, parece obvio que, si el equipo hubiera acordado una lista de verificación para determinar que una tarea estaba lista, las discusiones  descriptas no se habrían suscitado.</p>
			<p class="normal4">Y si el cliente y el equipo del segundo ejemplo hubieran acordado los casos de aceptación, habría quedado claro como se esperaba probar la entrega y el cliente hubiera tenido la posibilidad de indicar que iba a probar con el idioma árabe. Esto habría dado oportunidades al equipo para considerarlo en el desarrollo. A la vez, mientras se especificaban los casos para fijar el ambiente de pruebas, el cliente podría haber indicado que las pruebas debían ejecutarse correctamente en las nuevas impresoras o por lo menos, si no lo mencionaba, quedaría claro que la necesidad de impresión sobre otros dispositivos adicionales a los definidos originalmente serían un añadido y no una falla del producto original.</p>
			<p class="normal4">Ahora sí, con la definición de “Listo” del primer ejemplo y utilizando la técnica de los casos de aceptación como mostramos en la solución del segundo caso, tenemos he<a id="x.6176"></a>rramientas para favorecer un entendimiento común dentro del equipo y con nuestro cliente. En ambos casos <span class="char-style-override">la construcción es conjunta  </span>y requiere la participación tanto de quien genera el trabajo como de quien es el encargado de verificarlo ya que lo que se está haciendo es construyendo acuerdos. Ambas herramientas son relativamente sencillas de utilizar pero, junto a otras prácticas ágiles, brindan un gran poder para evitar conflictos, enfocar el trabajo y asegurar la satisfacción de quien recibe lo que hacemos.</p>
			<p class="normal4"> </p>
			<div class="marco-de-texto-b-sico">
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-82" href="part0012.html#footnote-668-82-backlink">82</a> En<span> </span>Sc<span>r</span>um<span> </span>se<span> </span>denomina<span> </span>Definition<span> </span>of<span> </span>Done<span> </span>(DoD)<span> </span>véase<span> </span><span>[Sc</span><span>r</span><span>umOrgDoD].</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-83" href="part0012.html#footnote-668-83-backlink">83</a> Un<span> </span>ejemplo<span> </span>puede<span> </span><span>v</span>e<span>r</span>se<span> </span>en<span> </span><span>[</span><span>W</span>ate<span>r</span><span>s</span><span> </span><span>2007].</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-84" href="part0012.html#footnote-668-84-backlink">84</a> <span class="t-tulo-2-car" xml:lang="en-US">Una excelente descripción del proceso de creación de la definición de Hecho se puede encontrar en [Lacey 2008]. </span></p>
				</div>
			</div>
		</div>
	</body></html>
