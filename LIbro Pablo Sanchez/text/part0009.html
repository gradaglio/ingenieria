<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>CONST_PRUEBA_EBOOK_FINAL-9</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body id="CONST_PRUEBA_EBOOK_FINAL" xml:lang="en-US" class="calibre">
		<div class="marco-de-texto-b-sico">
			<p id="toc_marker-9" class="heading">Empezando por la aceptación</p>
			<p class="normal4">Ya es viernes por la tarde y todo el equipo está muy cansado. Alejandro, que está probando la aplicación con el cliente, le dice a Marcio, desarrollador líder:</p>
			<p class="normal4">—Estuve probando incluir en la factura un ítem con precio unitario negativo, pero por algún motivo, no logro que funcione.</p>
			<p class="normal4">Marcio, satisfecho, contesta:</p>
			<p class="normal4">—Es que, precisamente, no tiene sentido que un artículo tenga precio negativo. Hasta incluí pruebas unitarias que validan que ningún precio unitario fuese negativo. ¿No es genial?</p>
			<p class="normal4">Sin embargo, Alejandro no está de acuerdo:</p>
			<p class="normal4">—Mm...Lamento tener que contradecirte, pero mientras definíamos los requerimientos surgió esta duda y Diego, el analista, me dijo que podía haber ítems con precios negativos. Es decir, ningún producto puede tener precio negativo, pero hay ítems que corresponden a descuentos, cuyos precios sí pueden ser negativos.</p>
			<p class="normal4">Marcio no termina de entender por qué a él no se le ocurrió esa posibilidad y pide reunirse con Diego lo antes posible.</p>
			<p class="normal4">La reunión con Diego no hace más que confirmar lo que decía Alejandro: hay ítems, que no son productos, que tienen precios unitarios negativos. Incluso Diego les informa que ninguna factura puede tener un total negativo, cosa que ni Marcio ni Alejandro habían previsto en su diseño. Como conclusión, Diego decide comunicar al cliente que la entrega de esta semana no va a incluir los ítems con precio negativo y Marcio queda encargado de agregar estos dos temas a la lista de tareas a realizar en la semana siguiente. Por suerte es viernes; el lunes, con la mente despejada, podrán seguir trabajando.</p>
			<p class="normal4">En un proyecto tradicional suele haber roles, tales como clientes, especialistas de negocio, analistas funcionales, programadores, testers, entre otros.</p>
			<p class="normal4">Estos roles, que no son los únicos posibles, y que suelen adquirir nombres distintos según la metodología o la costumbre, tienen asignadas determinadas responsabilidades. Por ejemplo, el analista de negocio suele ser el único interlocutor con el cliente, que trabaja entendiendo sus necesidades y construyendo especificaciones de los requerimientos que primero valida con el cliente y que luego serán usadas por programadores y testers. Los programadores toman dichas especificaciones y construyen el producto (código, base de datos y demás) basándose en los mismos. Los testers parten también de los requerimientos elaborados por el analista de negocio, toman el producto tal como está construido por los programadores y verifican que se haya construido siguiendo aquellos requerimientos. Finalmente, en algún momento, el producto llega al cliente. Como este validó los requerimientos con el analista, el producto se construyó de acuerdo a estos y los testers verificaron el producto, el cliente debería estar conforme con lo que recibe.</p>
			<p class="normal4">Sin embargo, las pruebas que realizamos para comprobar la satisfacción del cliente luego del desarrollo, muestran a menudo una disconformidad con el producto recibido. En este capítulo vamos a ver qué proponen los métodos ágiles para resolver este problema.</p>
			<p class="normal4"><span class="char-style-override2">Necesidad de criterios de aceptación</span></p>
			<p class="normal4">Una clave para mejorar los resultados es definir criterios de aceptación. Estos criterios son un conjunto de condiciones que nos deberían servir para definir, con la mayor claridad posible, los requerimientos justo antes de comenzar a desarrollarlos.</p>
			<p class="normal4">Si tuviésemos criterios de aceptación claramente definidos, y trabajados en conjunto  entre el equipo de desarrollo y el cliente, las probabilidades  de que este último no quede conforme al finalizar son mucho menores. Y todos ganaríamos confianza: el cliente en el equipo de desarrollo, y el equipo de desarrollo en el cliente.</p>
			<p class="normal4">Si, terminada una iteración, los criterios de aceptación de los requerimientos que se hayan encarado no son satisfechos por el producto, está claro que el cliente no va a estar conforme con lo que le entreguemos. Por lo tanto, conocer a priori los criterios de aceptación es una necesidad para todos los miembros del equipo de desarrollo, que pueden verificar lo que hacen contra esos criterios.</p>
			<p class="normal4">Si, en cambio, el producto satisface los criterios de aceptación, pero el cliente no está conforme, algo está mal en el proceso y eso es responsabilidad de todos los involucrados, tanto el cliente como el equipo. Por supuesto que esta realidad no es para ponernos contentos ya que se supone que el cliente debe estar satisfecho con lo que recibe. Estas situaciones deberían preocupar a todos los involucrados y ser tomadas como tema prioritario de la siguiente retrospectiva<span class="char-style-override3"><a id="footnote-668-28-backlink" href="part0009.html#footnote-668-28">28</a></span>. En un proceso iterativo, esto no debería ocurrir en varias iteraciones seguidas, ya que se supone que mediante las retrospectivas vamos aprendiendo a no cometer los mismos errores.</p>
			<p class="normal4">Pero eso no es todo. Los criterios de aceptación definidos con rigurosidad sirven para evitar que trabajemos para desarrollar funcionalidades que el cliente no esperaba. El famoso <span class="char-style-override">gold plating</span><span class="char-style-override6"><a id="footnote-668-29-backlink" href="part0009.html#footnote-668-29">29</a></span>, que se deriva de desarrollar más de lo que el cliente espera, no va a ocurrir, pues las funcionalidades superfluas no contarían con criterios de aceptación que las validen.</p>
			<p class="normal4">Por lo tanto, los criterios de aceptación sirven a los programadores para saber cuándo han completado el desarrollo de una funcionalidad.<span></span></p>
			<p class="normal3">La clásica pregunta “¿Cuándo sé que terminé mi trabajo con este requerimiento concreto<span class="char-style-override11">?”</span><span class="char-style-override11"> </span>se responde fácilmente: “cuando se satisfagan todos sus criterios de aceptación”.</p>
			<p class="normal4">Antes de seguir adelante, hagamos una aclaración. Cuando hablamos de criterios de aceptación para los requerimientos, no nos estamos restringiendo a los requerimientos funcionales. Los requerimientos de seguridad, de tiempo de respuesta, de escalabilidad, o cualquier otro no funcional o atributo de calidad, también necesitan criterios de aceptación claros que nos indiquen cómo se va a evaluar el producto una vez entregado. Tal vez incluso sean más importantes en estos casos que en los de requerimientos funcionales.</p>
			<p class="normal4">Por supuesto, los criterios de aceptación se pueden usar para elaborar indicadores de avance de un proyecto. Toda funcionalidad que satisfaga sus criterios de aceptación puede darse por concluida, con lo que la suma de requerimientos que cumplen con los criterios de aceptación nos brinda una medida clara del avance del proyecto y del valor entregado al cliente.</p>
			<p class="normal4">Como corolario:</p>
			<p class="normal3">Ningún requerimiento, funcional o de los otros, debería existir sin sus criterios de aceptación que permitan que el equipo sepa con qué se va a medir la corrección de aquello en lo que se está trabajando.</p>
			<p class="normal4">En<span> </span>otras<span> </span>palabras:</p>
			<p class="normal4">No deberían desarrollarse funcionalidades que no estén acompañadas por una prueba de aceptación. Y si durante una prueba, o en producción, surgiera un problema, habría que analizar que pasó con la prueba de aceptación correspondiente antes de resolverlo.</p>
			<p class="normal4"><span class="char-style-override2">Los criterios de aceptación</span> <span class="char-style-override2">se especifican mediante pruebas</span></p>
			<p class="normal4">La forma más natural de especificar criterios de aceptación es mediante pruebas. Al fin y al cabo, si un criterio de aceptación es aquello que sirve para determinar si el producto cumple o no con las expectativas del cliente, ¿no es muy parecido a lo que debería ser una prueba?</p>
			<p class="normal4">En efecto, un caso de prueba de aceptación, bien entendido, es un criterio de aceptación escrito de manera tal que un tester pueda ejecutarlo y ver si el producto cumple los requerimientos. Y un requerimiento, según lo que definimos más arriba, es un artefacto que debe venir acompañado de los criterios de aceptación que definan lo que el cliente espera del sistema.</p>
			<p class="normal4">Por lo tanto, una buena manera de elaborar un criterio de aceptación es darle el formato de un caso de prueba. Solo que este caso de prueba no se construye por y para los testers, sino que le sirve también a los programadores para guiar el desarrollo, medir avance y saber cuando terminaron, y al cliente para validar la entrega.</p>
			<p class="normal4">Como corolario, hemos llegado a una nueva definición de lo que es un caso de prueba de aceptación:</p>
			<p class="normal3">Un caso de prueba de aceptación es un escenario de ejecución del sistema con ciertos datos que permite definir si se cumplen o no los criterios de aceptación definidos por el cliente.</p>
			<p class="normal4">Un ejemplo de criterio de aceptación para una story de extracción de dinero podría ser <span class="char-style-override">si el usuario ingresa el monto 250 cuando su saldo es 100, el sistema debe rechazar la operación</span>.</p>
			<p class="normal4"><span class="char-style-override2">Las pruebas de usuario son ejemplos de uso</span></p>
			<p class="normal4">Por otro lado, los casos de prueba suelen ser escritos para probar el comportamiento  del sistema ante determinadas condiciones que el tester considera que deben ser probadas: el uso normal, tanto con valores típicos como con casos límite, entradas erróneas por parte de usuarios, fallas diversas, comportamiento en casos atípicos, entre otras. Pero, en cualquier caso, no son otra cosa que ejemplos de uso del sistema, teniendo en cuenta esas condiciones normales o excepcionales.</p>
			<p class="normal4">Lo que se busca al ejecutar pruebas es determinar si el sistema responde de acuerdo a lo esperado. En los casos de uso normal del sistema, se probará si responde a lo que se espera de él. Y en los demás casos también: si el manejo de errores es correcto, si se recupera correctamente luego de un fallo. Incluso puede que haya situaciones en las cuales se haya aceptado que el sistema no va a responder satisfactoriamente. Esos escenarios también deberían cubrirse por los casos de prueba.</p>
			<p class="normal4">Como se puede ver, estamos dando vueltas en círculos: planteamos que los requerimientos necesitan criterios de aceptación, que estos se expresan más claramente con casos de prueba, que estos son ejemplos de uso del sistema, y esos ejemplos surgen de los requerimientos.</p>
			<p class="normal4">Pero ese recorrido circular dista mucho de ser un problema.</p>
			<p class="normal4"><span class="char-style-override2">En definitiva, necesitamos ejemplos de uso del sistema</span></p>
			<p class="normal4">Todo lo anterior nos dice que si construimos ejemplos de uso del sistema mientras elaboramos nuestros requerimientos, van a servir para los desarrolladores, porque les darán una idea clara de lo que se espera del requerimiento, cuales son sus límites, y cuando pueden saber que su trabajo está terminado. Esos mismos ejemplos podrían servir como casos de prueba para verificar la calidad de lo que se va a entregar. Para el propio cliente, esos ejemplos le pueden servir para ver si se comporta como él esperaba. Y para los analistas de negocio, son materializaciones prácticas de las reglas de negocio.</p>
			<p class="normal4">Esto último también es importante para lo que venimos diciendo. Un analista de negocio suele elaborar sus requerimientos en base a distintas<span class="char-style-override1" xml:lang="ar-SA"> técnicas, pero en la generali</span>dad de los casos llevan a especificaciones abstractas, del estilo: “el usuario debe poder hacer envíos de dinero a través del sistema desde y hacia países de América y Europa”. En general, estas especificaciones de requerimientos se acompañan de una gran cantidad de aclaraciones, en la forma de excepciones, prototipos de pantalla, flujos de actividades y reglas de negocio. Las reglas de negocio también suelen quedar expresadas en forma asertiva como, por ejemplo, “los envíos de dinero sólo se podrán realizar en dólares estadounidenses, euros o monedas de países de la Unasur”.</p>
			<p class="normal4">El problema con estas especificaciones de requerimientos y reglas de negocio del sistema, es que no permiten ver con claridad que ocurre en casos límite: que debe hacer el sistema si el usuario intenta usar una moneda distinta o si el usuario desea seleccionar un país fuera de los permitidos, entre muchas otras posibilidades. Algunas de estas situaciones puede que sean informadas proactivamente por el cliente, o incluso que las prevea un analista de negocio sagaz y pregunte a aquel, y en ambos casos serán registradas como parte de los requerimientos o de las reglas de negocio. Pero suelen ser muchos los casos que se pasan por alto, y que recién se plantean cuando el tester se dispone a escribir casos de prueba, o incluso cuando tiene la aplicación a probar ya construida.</p>
			<p class="normal4">El inconveniente más serio de esta omisión es que se advierte luego de la construcción, cuando seguramente el programador ya tomó decisiones basadas en su mejor manera de entender los requerimientos, que puede o no coincidir con las expectativas  del cliente.</p>
			<p class="normal4">Hay quienes argumentan en favor de las especificaciones abstractas por sobre los ejemplos concretos. Sin embargo, estos últimos, precisamente por ser concretos, son más fáciles de comprender y acordar con los analistas de negocio y otros interesados, que entienden mejor los ejemplos concretos.</p>
			<p class="normal4">Al fin y al cabo, habitualmente un analista de negocio escribe especificaciones, que le sirven a los desarrolladores y a los testers. Los desarrolladores construyen su código y definen pruebas unitarias, para las cuales deben basarse en ejemplos de entradas y salidas. Los testers, por su lado, desarrollan casos de prueba, que contienen a su vez ejemplos. En algunas ocasiones, para fijar las especificaciones, los desarrolladores y los testers le solicitan a los analistas que les den ejemplos concretos para aclarar ideas. E incluso hay circunstancias en que los propios analistas proveen escenarios que no son otra cosa que requerimientos instanciados con ejemplos concretos.</p>
			<p class="normal4">En definitiva, hay varias ocasiones en que se plantean ejemplos que sirven como complementos de requerimientos. Por eso no es raro que se haya pensado en especificar directamente con ejemplos, o al menos acompañando los requerimientos con ellos.</p>
			<p class="normal4">Estos requerimientos con ejemplos tienen ciertas ventajas, de las cuales las más importantes son:</p>
			<p class="normal4">• Sirven como herramienta de comunicación.</p>
			<p class="normal4">• Se expresan por extensión, en vez de con largas descripciones y reglas en prosa, propensas a interpretaciones diversas.</p>
			<p class="normal4">• Al ser más concretos, son más sencillos de acordar con los clientes.</p>
			<p class="normal4">• Fomentan que los ejemplos que se usen sean los mismos para las distintas actividades, evitando que cada vez se escriban unos distintos, con su potencial divergencia.</p>
			<p class="normal4">• Sirven como pruebas de aceptación.</p>
			<p class="normal4">• Clarifican los criterios de aceptación.</p>
			<p class="normal4">• Facilitan la detección de errores mientras el contexto está fresco en la mente de los participantes.</p>
			<p class="normal4"><span class="char-style-override2">Algunas limitaciones</span></p>
			<p class="normal4">Sin embargo, no hay que olvidar que los requerimientos tradicionales tienen un nivel de abstracción mayor y expresan cuestiones que no siempre nos acordamos de llevar a los ejemplos. Por lo tanto, así como antes dijimos que todo requerimiento debe ir acompañado de pruebas de aceptación, también debemos poner el foco en que los escenarios o pruebas de aceptación deben estar claramente asociados a un requerimiento.</p>
			<p class="normal4">Además, no todo requerimiento puede llevarse a ejemplos. Por ejemplo, si una aplicación debe generar números al azar, los ejemplos que podamos escribir no van a servir como pruebas de aceptación.</p>
			<p class="normal4">Otra limitación de esta práctica se da en las situaciones en que la interacción es un requerimiento más importante que el comportamiento, como ocurre con las pruebas de usabilidad. Ya volveremos sobre esto.</p>
			<p class="normal4">Finalmente, nunca vamos a poder decir si el requerimiento quedó especificado en forma completa si solo definimos requerimientos con ejemplos, aunque sí vamos a poder garantizar que no sea ambiguo, validable contra las expectativas del cliente y verificable contra el producto.</p>
			<p class="normal4">Pero sigamos adelante para ver como se construyen estos ejemplos.</p>
			<p class="normal4"><span class="char-style-override2">Una manera distinta de trabajar</span></p>
			<p class="normal4">Lo que necesitamos, en definitiva, es tener ejemplos desde el comienzo. Para ello, lo ideal es mantener reuniones del equipo de desarrollo (incluyendo todos los roles del mismo: cliente, analistas, testers, programadores) que permitan construir esos ejemplos.</p>
			<p class="normal4">Conviene que estas reuniones sean en modalidad de taller<span class="char-style-override3"><a id="footnote-668-30-backlink" href="part0009.html#footnote-668-30">30</a></span>. La idea es ponerse de acuerdo en un lenguaje, una jerga, debatir y construir ejemplos en conjunto con el cliente, que luego sirvan para todo el equipo.</p>
			<p class="normal4">Aquí deben surgir los casos límite y las excepciones, y el equipo de desarrollo, incluyendo los que vayan a trabajar en testing, debe salir con todas sus preguntas respondidas o, al menos, con promesa de respuesta en el corto plazo.</p>
			<p class="normal4">El propio formato de taller hace que haya una revisión implícita, que surjan más requerimientos y reglas, y que se los tenga más presentes que cuando hay que leerlos de un documento escrito (esto independientemente de que luego se trasladen a un documento escrito).</p>
			<p class="normal4">Esas reuniones del cliente y el equipo de trabajo pueden tener distintas periodicidades, según las circunstancias del proyecto. Si podemos tener al cliente o un representante del mismo en contacto permanente con el equipo (que, como veremos en el capítulo “Reuniendo al equipo”, es lo más conveniente), las reuniones se podrán hacer al comenzar a trabajar en cada funcionalidad. Si el cliente solo puede mantener una presencia limitada o esporádica, habrá que agendar reuniones periódicas, tipo talleres, idealmente como mínimo al comenzar cada iteración. Si el cliente no está en el lugar, por ser un cliente remoto, vamos a necesitar hacer reuniones por videoconferencia o teleconferencia, cuanto más visuales mejor.</p>
			<p class="normal4">Lo que no puede ocurrir es que el cliente no esté presente siquiera en forma remota. Sin un cliente definiendo criterios de aceptación no hay criterios de aceptación, porque para poder construirlos de manera genuina se necesita de él, conocer sus opiniones y poder preguntar cara a cara. En este caso, como en tantos otros, la presencia del cliente es la clave del éxito.</p>
			<p class="normal4">No podemos dejar de recalcar que la comunicación cara a cara es fundamental en estas reuniones. Como veremos más adelante, las reuniones presenciales son una de las grandes recomendaciones del desarrollo ágil. En este caso, su importancia radica en que en situaciones en las que se está definiendo nada menos que lo que hay que hacer, los criterios de éxito y lo que no hay que hacer, la riqueza que da el lenguaje corporal no es reemplazable por otras formas de comunicación [Cockburn 2001].</p>
			<p class="normal4">Por eso, para evitar el síndrome del teléfono descompuesto<span class="char-style-override3"><a id="footnote-668-31-backlink" href="part0009.html#footnote-668-31">31</a></span>, se deben preferir siempre las reuniones cara a cara. Si no fuera posible, se pueden hacer talleres por videoconferencia, que es el mejor sucedáneo, sin la ventaja de la presencia real. Si esta modalidad también es imposible, la reunión telefónica podría servir, aunque estaremos perdiendo toda la información que brinda el lenguaje gestual y corporal. Finalmente, está el recurso de recurrir a la escritura, mediante mensajería instantánea o correo electrónico, que son desde todo punto de vista las peores alternativas, porque ni siquiera permiten dilucidar los tonos de voz<span class="char-style-override3"><a id="footnote-668-32-backlink" href="part0009.html#footnote-668-32">32</a></span>.</p>
			<p class="normal4"><span class="char-style-override2">El diseño también se puede especificar con pruebas</span></p>
			<p class="normal4">Venimos hablando de construir criterios de aceptación de los requerimientos, con formato de ejemplos, que luego sirvan como casos de prueba del producto.</p>
			<p class="normal4">Sin embargo, no estamos teniendo en cuenta en todo esto al diseño, que también admite un tratamiento similar.</p>
			<p class="normal4">Una vez definidos los criterios de aceptación de un requerimiento, en forma de pruebas, se pueden  escribir pruebas de mayor granularidad que, cumpliendo con estos criterios, sirvan como una medida de la calidad de su diseño e implementación.</p>
			<p class="normal4">Esta tarea la puede hacer un conjunto de programadores, un par de ellos, o simplemente un programador aislado antes de comenzar a desarrollar una funcionalidad.</p>
			<p class="normal4">Hace ya más de una década que surgió una práctica de diseño de software orientado a objetos, llamada TDD (Test-Driven Development<span class="char-style-override3"><a id="footnote-668-33-backlink" href="part0009.html#footnote-668-33">33</a></span>), que se basa en derivar el código de pruebas escritas antes del mismo. Fue presentada como parte de Extreme Programming (XP) por Kent Beck [Beck 1999].</p>
			<p class="normal4">Se ha utilizado para poner el énfasis en hacer pequeñas pruebas de unidad que garanticen la cohesión de las clases, así como en pruebas de integración (de escenarios con varias clases) que aseguren la calidad del diseño y la separación de incumbencias, disminuyendo el acoplamiento. Dicho sea de paso, TDD recomienda que las pruebas sean especificadas en código, pero este tema lo analizaremos en el capítulo “Probar, probar, probar”.</p>
			<p class="normal4">Hay una regla de oro de TDD que conviene destacar: “Nunca escribas nueva funcionalidad sin una prueba que falle antes” [Beck 2002]. Otra dice: “Si no puedes escribir una prueba para lo que estás por codificar, entonces no deberías estar pensando en codificar” [Chaplin 2001]. El corolario obvio es que ninguna funcionalidad futura debería escribirse por adelantado, si no tiene el conjunto de pruebas que permita verificar su corrección. Si a eso se le suma que solo se debería escribir de a una prueba por vez, tenemos un desarrollo incremental extremo, definido por pequeños incrementos que se corresponden con funcionalidades bien acotadas.</p>
			<p class="normal4">Notemos que estamos hablando de una práctica de diseño, no de control de calidad (o al menos no principalmente), ya que al escribir las pruebas antes del propio código productivo estamos derivando código a partir de las mismas. En definitiva, las pruebas explicitan el diseño del sistema.</p>
			<p class="normal4">Esto ha llevado a algunos equívocos que provienen del propio nombre de TDD, que incluye la palabra “test”. En efecto, mientras por un lado se afirma que es una técnica de diseño y no de pruebas, por el otro, el nombre invita a pensar otra cosa. Incluso las herramientas que fueron surgiendo a partir de TDD, desarrolladas incluso por los mentores de la práctica, requerían que el código de pruebas tuviese métodos cuyos nombres empezasen con <span class="char-style-override">test </span>y las clases fueran descendientes de algo como <span class="char-style-override">TestCase</span><span class="char-style-override6"><a id="footnote-668-34-backlink" href="part0009.html#footnote-668-34">34</a></span><span class="char-style-override">.</span> Nadie niega que TDD genera un buen conjunto de pruebas de regresión, pero ese no pretende ser su objetivo principal, sino más bien un efecto lateral positivo. Para colmo, es una práctica centrada en la programación, con lo cual no parece enfocada en especialistas del negocio ni testers; de hecho, los testers tradicionales tienden a desconfiar de ella por este mismo motivo.</p>
			<p class="normal4">Un poco al pasar, dijimos que en los talleres de discusión de requerimientos con los clientes podía ir surgiendo el vocabulario del proyecto. Esto también es una cuestión que hace al diseño. Eric Evans [Evans 2003], al presentar su práctica de Domain Driven Design<span class="char-style-override3"><a id="footnote-668-35-backlink" href="part0009.html#footnote-668-35">35</a></span>, asignó importancia fundamental a lo ubicuo del lenguaje, poniendo énfasis en que los nombres de las clases y métodos<span class="char-style-override3"><a id="footnote-668-36-backlink" href="part0009.html#footnote-668-36">36</a></span> de un sistema deberían surgir de los conceptos del dominio.</p>
			<p class="normal4">Efectivamente, el uso de un vocabulario común entre personas que cubren distintos roles y en actividades distintas es una ventaja que debería llegar hasta los nombres en el código.</p>
			<p class="normal4"><span class="char-style-override2">El mundo al revés</span></p>
			<p class="normal4">Como estamos viendo, en el desarrollo ágil, empezamos creando criterios de aceptación como pruebas de mayor nivel. Luego, escribimos pruebas técnicas que nos permitan definir el diseño, incluyendo los nombres que vamos a usar, tanto en la comunicación con el equipo y el cliente, como en el código. Y, por último, construimos el código que responda a ambos tipos de pruebas. El diagrama de la figura 6.1 muestra este proceso.</p>
			<p class="normal4"><span class="char-style-override2">Figura  6.1 Ciclo  de  desarrollo basado en pruebas.</span></p>
			<p class="normal4"><span class="char-style-override2"><span><img class="frame14" src="../images/00014.jpeg" alt="6.1.jpg"/></span> </span></p>
			<p class="normal4">Puede que a las personas que trabajan con procesos tradicionales les parezca descabellado escribir pruebas antes de construir el software que esas pruebas van a verificar. Creemos que lo explicado en este capítulo debería bastar para contar con buenas razones para hacerlo. Como veremos enseguida, estas ideas llevan ya bastante tiempo dando vuelta en el desarrollo de software, y se les ha dado nombres diversos.</p>
			<p class="normal4">Además, hay una ventaja adicional en escribir las pruebas basándonos en requerimientos o en cuestiones de diseño, antes de programar una sola línea de lo que las pruebas deberían verificar. Es una aspiración casi tan vieja como el desarrollo de software: al escribir las pruebas antes, estamos especificando lo que queremos (el qué) sin ceñirnos a una implementación (el cómo). Esto permitiría que más adelante realicemos implementaciones alternativas para las mismas pruebas, y esas implementaciones se podrían verificar con el mismo conjunto de pruebas que la implementación original.</p>
			<p class="normal4"><span class="char-style-override2">De TDD a STDD</span></p>
			<p class="normal4">Como hemos dicho antes, si hiciésemos historia, la primera noción de TDD, y por lo tanto de las ventajas de escribir pruebas antes del código, fue conocida para el gran público a partir de la publicación del libro de XP [Beck 1999]. En este libro, Beck hacía énfasis tanto en las pruebas de menor nivel, como en las de aceptación, a las que llamaba “pruebas de cliente”.</p>
			<p class="normal4">Sin embargo, poco a poco, y sin que nadie pueda explicar bien por qué, TDD fue haciéndose sinónimo de algo como UTDD (Unit Test-Driven Development, o TDD con pruebas de unidad). Las herramientas que fueron surgiendo, entre ellas algunas en las que el mismo Beck tuvo mucho que ver, impulsaron aún más esta noción.</p>
			<p class="normal4">Como respuesta a este sesgo terminológico, que  fue convirtiendo a TDD en sinónimo de UTDD,  fueron surgiendo otros acrónimos, que pretendieron extender TDD para cubrir nuevamente a las pruebas de aceptación, bien en línea con lo que proponen los métodos ágiles que, como ya sabemos, tienen como foco principal el valor para el cliente.</p>
			<p class="normal4">Uno de los primeros que advirtió esto fue Dan North [North 2006], quien sostiene que poner el foco en el comportamiento logra un grado mayor de abstracción al escribir las pruebas desde el punto de vista del consumidor y no del productor. Por supuesto, recibió críticas por esto, al punto que hubo varios que dijeron que eso era lo mismo que hacer bien TDD<span class="char-style-override3"><a id="footnote-668-37-backlink" href="part0009.html#footnote-668-37">37</a></span>.</p>
			<p class="normal4">Los acrónimos más habituales<span class="char-style-override3"><a id="footnote-668-38-backlink" href="part0009.html#footnote-668-38">38</a></span> son:</p>
			<p class="normal4">• TDD  (Test-Driven Development):  en  teoría, el  más abarcativo, pero  habitualmente  usado  como  sinónimo de UTDD. También se usa como una extensión de UTDD mediante pruebas técnicas de integración, tema que veremos en el capítulo “Probar, probar, probar”.</p>
			<p class="normal4">• UTDD  (Unit Test-Driven Development): centrado en especificación del diseño detallado (por ejemplo, si trabajamos en programación orientada a objetos, a nivel de métodos y objetos).</p>
			<p class="normal4">• BDD (Behavior-Driven Development<span class="char-style-override3"><a id="footnote-668-39-backlink" href="part0009.html#footnote-668-39">39</a></span>): se basa en criterios de aceptación, aunque se los denomine especificaciones de comportamiento. Se suele usar tanto para especificar requerimientos como diseño de alto nivel. Muchos lo consideran sinónimo de ATDD, STDD y SBE.</p>
			<p class="normal4">• ATDD (Acceptance Test-Driven Development<span class="char-style-override3"><a id="footnote-668-40-backlink" href="part0009.html#footnote-668-40">40</a></span>): basado en criterios de aceptación exclusivamente. Muchos lo consideran sinónimo de BDD, STDD y SBE.</p>
			<p class="normal4">• STDD (Storytest-Driven Development<span class="char-style-override3"><a id="footnote-668-41-backlink" href="part0009.html#footnote-668-41">41</a></span>): basado en la especificación de requerimientos usando pruebas. Muchos lo consideran sinónimo de BDD, ATDD y SBE.</p>
			<p class="normal4">• SBE (Specification By  Example<span class="char-style-override3"><a id="footnote-668-42-backlink" href="part0009.html#footnote-668-42">42</a></span>): prácticamente  lo mismo que STDD, aunque el foco está puesto en los ejemplos como herramienta de comunicación entre roles y de especificación de criterios de aceptación en forma de ejemplos.</p>
			<p class="normal4">No obstante, como todo lo que se refiere a TDD implica por lo menos automatización y refactorización, y esos son temas que trataremos en el capítulo mencionado.</p>
			<p class="normal4">• Mejorar la visibilidad de la satisfacción de requerimientos y del avance.</p>
			<p class="normal4">• Disminuir el <span class="char-style-override">gold-plating.</span></p>
			<p class="normal4">• Usar un lenguaje único, más cerca del consumidor.</p>
			<p class="normal4">• Mejorar la comunicación.</p>
			<p class="normal4">Tengamos en cuenta, además, que hay dos maneras de ver la calidad: una interna, la que les sirve a los desarrolladores, y otra externa, la que perciben usuarios y clientes. UTDD y la acepción más habitual de TDD apuntan a la calidad interna, mientras que BDD, ATDD y STDD apuntan a la externa. Otra manera de verlo es que, así como UTDD pretende ser una técnica de diseño detallado, BDD se presenta como una de diseño basado en dominio y ATDD una de requerimientos. En el capítulo “Probar, probar, probar” nos centraremos en temas de automatización de todo este proceso.</p>
			<p class="normal4"><a id="x.4714"></a> </p>
			<div class="marco-de-texto-b-sico">
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-28" href="part0009.html#footnote-668-28-backlink">28</a> Una retrospectiva es una reunión típica de los proyectos ágiles, que se realiza para analizar que se puede mejorar y que mantener, con foco en la última iteración. Como veremos en el capítulo “En retrospectiva”, es una instancia de mejora y aprendizaje.</p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-29" href="part0009.html#footnote-668-29-backlink">29</a> <span class="t-tulo-2-car" xml:lang="en-US">En la jerga de administración de proyectos, se denomina “gold-plating” (literalmente, “enchapado en oro”) a incorporar funcionalidades o cualidades a un producto aunque el cliente no lo necesite ni lo haya solicitado.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-30" href="part0009.html#footnote-668-30-backlink">30</a> <span class="t-tulo-2-car" xml:lang="en-US">Llamamos “taller” a una reunión presencial, en la que varias personas, actuando como pares, discuten puntos de vista, plantean dudas, hacen preguntas, proponen alternativas y clarifican conceptos.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-31" href="part0009.html#footnote-668-31-backlink">31</a> <span class="t-tulo-2-car" xml:lang="en-US">Nos referimos al juego del teléfono descompuesto o roto, como se lo conoce en distintos países. Es un juego en el que se ve cómo un mensaje se va distorsionando al pasar de un participante a otro, al punto de quedar irreconocible al final de una ronda.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-32" href="part0009.html#footnote-668-32-backlink">32</a> <span class="t-tulo-2-car" xml:lang="en-US">Véase el patrón “Face to  Face Before Working  Remotely” (en castellano, “Cara a cara antes de trabajar en forma remota”) en [Coplien 2004].</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-33" href="part0009.html#footnote-668-33-backlink">33</a> <span class="t-tulo-2-car" xml:lang="en-US">En castellano, “Desarrollo guiado por las pruebas”.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-34" href="part0009.html#footnote-668-34-backlink">34</a> <span class="t-tulo-2-car" xml:lang="en-US">Si bien NUnit y la versión 4 de JUnit mejoraron esto, sigue estando presente la palabra Test en las anotaciones que utilizan.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-35" href="part0009.html#footnote-668-35-backlink">35</a> <span class="t-tulo-2-car" xml:lang="en-US">En castellano, “Diseño guiado por el dominio”.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-36" href="part0009.html#footnote-668-36-backlink">36</a> <span class="t-tulo-2-car" xml:lang="en-US">Evans trabaja dentro del paradigma de objetos.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-37" href="part0009.html#footnote-668-37-backlink">37</a> <span class="t-tulo-2-car" xml:lang="en-US">Véase, por ejemplo, [Glover 2007].</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-38" href="part0009.html#footnote-668-38-backlink">38</a> <span class="t-tulo-2-car" xml:lang="en-US">Hay decenas de acrónimos y nombres que se han difundido. Aquí enumeramos los más habituales, incluso sabiendo que los límites entre lo que significan unos y otros no están claramente definidos.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-39" href="part0009.html#footnote-668-39-backlink">39</a> <span class="t-tulo-2-car" xml:lang="en-US">En castellano, “Desarrollo guiado por el comportamiento”.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-40" href="part0009.html#footnote-668-40-backlink">40</a> En<span> </span><span>castellan</span><span>o</span><span>,</span><span> </span>“Desa<span>r</span><span>r</span>ollo<span> </span>guiado<span> </span>por<span> </span>p<span>r</span>uebas<span> </span>de<span> </span><span>aceptación”.</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-41" href="part0009.html#footnote-668-41-backlink">41</a> <span class="t-tulo-2-car" xml:lang="en-US">En castellano, “Desarrollo guiado por pruebas de requerimientos”. Ver [Mugridge 2008].</span></p>
				</div>
				<div class="marco-de-texto-b-sico">
					<p class="footnote-text"><a id="footnote-668-42" href="part0009.html#footnote-668-42-backlink">42</a> En <span> </span>castellan<span>o</span>,<span> </span>“especificación<span> </span>mediante <span> </span>ejemplos”.<span> </span>Véase<span> </span>[Ma<span>r</span>ick  <span>2002], </span>[Ma<span>r</span>ick<span> </span>2003],<span> </span>[Adzic<span> </span><span>2009].</span></p>
				</div>
			</div>
		</div>
	</body></html>
